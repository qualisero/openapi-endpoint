import * as fs from 'fs'
import * as path from 'path'
import { exec } from 'child_process'
import { promisify } from 'util'
import { HttpMethod } from './types.js'

const execAsync = promisify(exec)

interface OpenAPIOperation {
  operationId?: string
  [key: string]: unknown
}

interface OpenAPIPath {
  [method: string]: OpenAPIOperation
}

interface OpenAPISpec {
  paths: {
    [path: string]: OpenAPIPath
  }
}

interface OperationInfo {
  path: string
  method: HttpMethod
}

async function fetchOpenAPISpec(input: string): Promise<string> {
  // Check if input is a URL
  if (input.startsWith('http://') || input.startsWith('https://')) {
    console.log(`üì° Fetching OpenAPI spec from URL: ${input}`)

    // Use node's built-in fetch (available in Node 18+)
    try {
      const response = await fetch(input)
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      const content = await response.text()
      return content
    } catch (error) {
      throw new Error(`Failed to fetch OpenAPI spec from URL: ${error}`)
    }
  } else {
    // Local file
    console.log(`üìÇ Reading OpenAPI spec from file: ${input}`)

    if (!fs.existsSync(input)) {
      throw new Error(`File not found: ${input}`)
    }

    return fs.readFileSync(input, 'utf8')
  }
}

async function generateTypes(openapiContent: string, outputDir: string): Promise<void> {
  console.log('üî® Generating TypeScript types using openapi-typescript...')

  // Write the OpenAPI spec to a temporary file
  const tempSpecPath = path.join(outputDir, 'temp-openapi.json')
  fs.writeFileSync(tempSpecPath, openapiContent)

  try {
    // Run openapi-typescript
    const typesOutputPath = path.join(outputDir, 'openapi-types.ts')
    const command = `npx openapi-typescript "${tempSpecPath}" --output "${typesOutputPath}"`

    await execAsync(command)
    console.log(`‚úÖ Generated types file: ${typesOutputPath}`)
    // Format the generated file using eslint --fix
    console.log('üé® Formatting generated types file with ESLint...')
    const eslintCommand = `npx eslint --fix "${typesOutputPath}"`
    await execAsync(eslintCommand)
    console.log(`‚úÖ Formatted types file: ${typesOutputPath}`)
  } finally {
    // Clean up temp file
    if (fs.existsSync(tempSpecPath)) {
      fs.unlinkSync(tempSpecPath)
    }
  }
}

function parseOperationsFromSpec(openapiContent: string): {
  operationIds: string[]
  operationInfoMap: Record<string, OperationInfo>
} {
  const openApiSpec: OpenAPISpec = JSON.parse(openapiContent)

  if (!openApiSpec.paths) {
    throw new Error('Invalid OpenAPI spec: missing paths')
  }

  const operationIds: string[] = []
  const operationInfoMap: Record<string, OperationInfo> = {}

  // Iterate through all paths and methods to extract operationIds
  Object.entries(openApiSpec.paths).forEach(([pathUrl, pathItem]) => {
    Object.entries(pathItem).forEach(([method, operation]) => {
      // Skip non-HTTP methods (like parameters)
      const httpMethods = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head', 'trace']
      if (!httpMethods.includes(method.toLowerCase())) {
        return
      }

      const op = operation as OpenAPIOperation
      if (op.operationId) {
        operationIds.push(op.operationId)
        operationInfoMap[op.operationId] = {
          path: pathUrl,
          method: method.toUpperCase() as HttpMethod,
        }
      }
    })
  })

  // Keep original order from OpenAPI spec for consistency with existing fixtures

  return { operationIds, operationInfoMap }
}

function generateApiOperationsContent(operationIds: string[], operationInfoMap: Record<string, OperationInfo>): string {
  // Generate operationsBase dictionary
  const operationsBaseContent = operationIds
    .map((id) => {
      const info = operationInfoMap[id]
      return `  ${id}: {\n    path: '${info.path}',\n    method: HttpMethod.${info.method},\n  },`
    })
    .join('\n')

  // Generate OperationId enum content
  const operationIdContent = operationIds.map((id) => `  ${id}: '${id}' as const,`).join('\n')

  return `// Auto-generated from OpenAPI specification
// Do not edit this file manually

import type { operations } from './openapi-types'

export enum HttpMethod {
  GET = 'GET',
  POST = 'POST',
  PUT = 'PUT',
  PATCH = 'PATCH',
  DELETE = 'DELETE',
  HEAD = 'HEAD',
  OPTIONS = 'OPTIONS',
  TRACE = 'TRACE',
}

// Create the typed structure that combines operations with operation metadata
// This ensures the debug method returns correct values and all operations are properly typed
const operationsBase = {
${operationsBaseContent}
} as const

// Merge with operations type to maintain OpenAPI type information
export const openApiOperations = operationsBase as typeof operationsBase & operations

export type OpenApiOperations = typeof openApiOperations

// Dynamically generate OperationId enum from the operations keys
export const OperationId = {
${operationIdContent}
} satisfies Record<keyof typeof operationsBase, keyof typeof operationsBase>

// Export the type for TypeScript inference
export type OperationId = keyof OpenApiOperations
`
}

async function generateApiOperations(openapiContent: string, outputDir: string): Promise<void> {
  console.log('üî® Generating api-operations.ts file...')

  const { operationIds, operationInfoMap } = parseOperationsFromSpec(openapiContent)

  // Generate TypeScript content
  const tsContent = generateApiOperationsContent(operationIds, operationInfoMap)

  // Write to output file
  const outputPath = path.join(outputDir, 'api-operations.ts')
  fs.writeFileSync(outputPath, tsContent)

  console.log(`‚úÖ Generated api-operations file: ${outputPath}`)
  console.log(`üìä Found ${operationIds.length} operations`)
}

function printUsage(): void {
  console.log(`
Usage: npx @qualisero/openapi-endpoint <openapi-input> <output-directory>

Arguments:
  openapi-input      Path to OpenAPI JSON file or URL to fetch it from
  output-directory   Directory where generated files will be saved

Examples:
  npx @qualisero/openapi-endpoint ./api/openapi.json ./src/generated
  npx @qualisero/openapi-endpoint https://api.example.com/openapi.json ./src/api

This command will generate:
  - openapi-types.ts    (TypeScript types from OpenAPI spec)
  - api-operations.ts   (Operation IDs and info for use with this library)
`)
}

async function main(): Promise<void> {
  const args = process.argv.slice(2)

  if (args.length === 0 || args.includes('--help') || args.includes('-h')) {
    printUsage()
    process.exit(0)
  }

  if (args.length !== 2) {
    console.error('‚ùå Error: Exactly 2 arguments are required')
    printUsage()
    process.exit(1)
  }

  const [openapiInput, outputDir] = args

  try {
    // Ensure output directory exists
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true })
      console.log(`üìÅ Created output directory: ${outputDir}`)
    }

    // Fetch OpenAPI spec content
    const openapiContent = await fetchOpenAPISpec(openapiInput)

    // Generate both files
    await Promise.all([generateTypes(openapiContent, outputDir), generateApiOperations(openapiContent, outputDir)])

    console.log('üéâ Code generation completed successfully!')
  } catch (error) {
    console.error('‚ùå Error:', error instanceof Error ? error.message : error)
    process.exit(1)
  }
}

// Auto-execute main function
main().catch((error) => {
  console.error('‚ùå Unexpected error:', error)
  process.exit(1)
})
