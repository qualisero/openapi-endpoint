<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>JSDoc: Source: index.ts</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css" />
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css" />
  </head>

  <body>
    <div id="main">
      <h1 class="page-title">Source: index.ts</h1>

      <section>
        <article>
          <pre class="prettyprint source linenums"><code>import type { MaybeRefOrGetter } from 'vue'
import { QueryClient } from '@tanstack/vue-query'

import { useEndpoint } from './openapi-endpoint'
import { EndpointQueryReturn, useEndpointQuery } from './openapi-query'
import { EndpointMutationReturn, useEndpointMutation } from './openapi-mutation'
import {
  Operations,
  GetPathParameters,
  OpenApiConfig,
  QQueryOptions,
  QMutationOptions,
  IsQueryOperation,
} from './types'
import { getHelpers } from './openapi-helpers'
export type { OperationInfo, QQueryOptions, OpenApiConfig, OpenApiInstance } from './types'
export { type EndpointQueryReturn, useEndpointQuery } from './openapi-query'
export { type EndpointMutationReturn, useEndpointMutation } from './openapi-mutation'

/**
 * Default QueryClient instance with pre-configured options.
 *
 * This client is used by default when no custom QueryClient is provided to useOpenApi.
 * It includes sensible defaults like 5-minute stale time for queries.
 */
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: { staleTime: 1000 * 60 * 5 },
  },
})

/**
 * Creates a type-safe OpenAPI client for Vue applications.
 *
 * This is the main entry point for the library. It provides reactive composables
 * for API operations with full TypeScript type safety based on your OpenAPI specification.
 *
 * @template Ops - The operations type, typically generated from your OpenAPI spec
 * @param config - Configuration object containing operations metadata and axios instance
 * @returns API instance with useQuery, useMutation, useEndpoint, and debug methods
 *
 * @example
 * ```typescript
 * import { useOpenApi } from '@qualisero/openapi-endpoint'
 * import { openApiOperations, type OpenApiOperations } from './generated/api-operations'
 * import axios from 'axios'
 *
 * const api = useOpenApi&lt;OpenApiOperations>({
 *   operations: openApiOperations,
 *   axios: axios.create({ baseURL: 'https://api.example.com' })
 * })
 *
 * // Use in components
 * const { data, isLoading } = api.useQuery('listPets', {})
 * const createPet = api.useMutation('createPet', {})
 * ```
 */
export function useOpenApi&lt;Ops extends Operations&lt;Ops>>(config: OpenApiConfig&lt;Ops>) {
  return {
    /**
     * Debug utility to inspect operation metadata.
     *
     * @param operationId - The operation ID to debug
     * @returns Information about whether the operation is a query operation
     */
    _debugIsQueryOperation: function &lt;Op extends keyof Ops>(operationId: Op) {
      const helpers = getHelpers&lt;Ops, Op>(config)
      const info = helpers.getOperationInfo(operationId)
      console.log('Operation Info:', info)
      return {} as IsQueryOperation&lt;Ops, Op>
    },

    /**
     * Creates a reactive query for GET operations.
     *
     * This composable wraps TanStack Query for read-only operations with automatic
     * type inference, caching, and reactive updates.
     *
     * @template Op - The operation key from your operations type
     * @param operationId - Operation ID (must be a GET operation)
     * @param pathParamsOrOptions - Path parameters or query options
     * @param optionsOrNull - Additional query options when path params are provided
     * @returns Reactive query result with data, loading state, error handling, etc.
     *
     * @example
     * ```typescript
     * // Query without path parameters
     * const { data: pets, isLoading } = api.useQuery(OperationId.listPets, {
     *   enabled: true,
     *   onLoad: (data) => console.log('Loaded:', data)
     * })
     *
     * // Query with path parameters
     * const { data: pet } = api.useQuery(OperationId.getPet, { petId: '123' }, {
     *   enabled: computed(() => Boolean(petId.value))
     * })
     * ```
     */
    useQuery: function &lt;Op extends keyof Ops>(
      operationId: IsQueryOperation&lt;Ops, Op> extends true ? Op : never,
      pathParamsOrOptions?: GetPathParameters&lt;Ops, Op> extends Record&lt;string, never>
        ? QQueryOptions&lt;Ops, Op>
        : MaybeRefOrGetter&lt;GetPathParameters&lt;Ops, Op> | null | undefined> | QQueryOptions&lt;Ops, Op>,
      optionsOrNull?: QQueryOptions&lt;Ops, Op>,
    ): EndpointQueryReturn&lt;Ops, Op> {
      const helpers = getHelpers&lt;Ops, Op>(config)

      return useEndpointQuery&lt;Ops, Op>(operationId, helpers, pathParamsOrOptions, optionsOrNull)
    },

    /**
     * Creates a reactive mutation for POST/PUT/PATCH/DELETE operations.
     *
     * This composable wraps TanStack Query's useMutation for data-modifying operations
     * with automatic cache invalidation and optimistic updates.
     *
     * @template Op - The operation key from your operations type
     * @param operationId - Operation ID (must be a mutation operation)
     * @param pathParamsOrOptions - Path parameters or mutation options
     * @param optionsOrNull - Additional mutation options when path params are provided
     * @returns Reactive mutation result with mutate, mutateAsync, status, etc.
     *
     * @example
     * ```typescript
     * // Mutation without path parameters
     * const createPet = api.useMutation(OperationId.createPet, {
     *   onSuccess: (data) => console.log('Created:', data),
     *   onError: (error) => console.error('Failed:', error)
     * })
     *
     * // Mutation with path parameters
     * const updatePet = api.useMutation(OperationId.updatePet, { petId: '123' }, {
     *   onSuccess: async () => {
     *     // Automatically invalidates related queries
     *   }
     * })
     *
     * // Execute the mutation
     * await createPet.mutateAsync({ data: { name: 'Fluffy' } })
     * ```
     */
    useMutation: function &lt;Op extends keyof Ops>(
      operationId: IsQueryOperation&lt;Ops, Op> extends false ? Op : never,
      pathParamsOrOptions?: GetPathParameters&lt;Ops, Op> extends Record&lt;string, never>
        ? QMutationOptions&lt;Ops, Op>
        : MaybeRefOrGetter&lt;GetPathParameters&lt;Ops, Op> | null | undefined> | QMutationOptions&lt;Ops, Op>,
      optionsOrNull?: QMutationOptions&lt;Ops, Op>,
    ) {
      const helpers = getHelpers&lt;Ops, Op>(config)

      return useEndpointMutation&lt;Ops, Op>(operationId, helpers, pathParamsOrOptions, optionsOrNull)
    },

    /**
     * Generic endpoint composable that automatically detects operation type.
     *
     * This is a universal composable that returns either a query or mutation based
     * on the operation's HTTP method. Use this when you want unified handling.
     *
     * @template Op - The operation key from your operations type
     * @param operationId - Any operation ID
     * @param pathParamsOrOptions - Path parameters or operation options
     * @param optionsOrNull - Additional options when path params are provided
     * @returns Query result for GET operations, mutation result for others
     *
     * @example
     * ```typescript
     * // Automatically becomes a query for GET operations
     * const listEndpoint = api.useEndpoint(OperationId.listPets)
     *
     * // Automatically becomes a mutation for POST operations
     * const createEndpoint = api.useEndpoint(OperationId.createPet)
     *
     * // TypeScript knows the correct return type based on the operation
     * const data = listEndpoint.data // Query data
     * await createEndpoint.mutateAsync({ data: petData }) // Mutation execution
     * ```
     */
    useEndpoint: function &lt;Op extends keyof Ops>(
      operationId: Op,
      pathParamsOrOptions?: GetPathParameters&lt;Ops, Op> extends Record&lt;string, never>
        ? IsQueryOperation&lt;Ops, Op> extends true
          ? QQueryOptions&lt;Ops, Op>
          : QMutationOptions&lt;Ops, Op>
        :
            | MaybeRefOrGetter&lt;GetPathParameters&lt;Ops, Op> | null | undefined>
            | (IsQueryOperation&lt;Ops, Op> extends true ? QQueryOptions&lt;Ops, Op> : QMutationOptions&lt;Ops, Op>),
      optionsOrNull?: IsQueryOperation&lt;Ops, Op> extends true ? QQueryOptions&lt;Ops, Op> : QMutationOptions&lt;Ops, Op>,
    ): IsQueryOperation&lt;Ops, Op> extends true ? EndpointQueryReturn&lt;Ops, Op> : EndpointMutationReturn&lt;Ops, Op> {
      const helpers = getHelpers&lt;Ops, Op>(config)

      return useEndpoint&lt;Ops, Op>(operationId, helpers, pathParamsOrOptions, optionsOrNull)
    },
  }
}
</code></pre>
        </article>
      </section>
    </div>

    <nav>
      <h2><a href="index.html">Home</a></h2>
      <h3>Global</h3>
      <ul>
        <li><a href="global.html#_debugIsQueryOperation">_debugIsQueryOperation</a></li>
        <li><a href="global.html#queryClient">queryClient</a></li>
        <li><a href="global.html#useEndpoint">useEndpoint</a></li>
        <li><a href="global.html#useEndpointMutation">useEndpointMutation</a></li>
        <li><a href="global.html#useEndpointQuery">useEndpointQuery</a></li>
        <li><a href="global.html#useMutation">useMutation</a></li>
        <li><a href="global.html#useOpenApi">useOpenApi</a></li>
        <li><a href="global.html#useQuery">useQuery</a></li>
      </ul>
    </nav>

    <br class="clear" />

    <footer>
      Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Sat Oct 11 2025 22:44:45
      GMT+0000 (Coordinated Universal Time)
    </footer>

    <script>
      prettyPrint()
    </script>
    <script src="scripts/linenumber.js"></script>
  </body>
</html>
