import { describe, it, expect, vi, beforeEach } from 'vitest'
import { useOpenApi } from '@/index'
import { OpenApiConfig, type OpenApiInstance } from '@/types'
import { mockAxios } from '../setup'
import { OperationId, openApiOperations, type OpenApiOperations } from '../fixtures/openapi-typed-operations'

/**
 * Bug Fixes and Issue Reproductions
 *
 * This file consolidates all bug-specific tests with proper references to GitHub issues and PRs.
 * Each test section references the specific issue it addresses.
 */
describe('Bug Fixes and Issue Reproductions', () => {
  const mockOperations: OpenApiOperations = openApiOperations

  let mockConfig: OpenApiConfig<OpenApiOperations>
  let api: OpenApiInstance<OpenApiOperations>

  beforeEach(() => {
    vi.clearAllMocks()
    mockConfig = {
      operations: mockOperations,
      axios: mockAxios,
    }
    api = useOpenApi(mockConfig)
  })

  /**
   * Issue: Typing error when augmenting axiosOptions
   *
   * Problem: TypeScript errors when using custom axios properties that are defined
   * through module augmentation, specifically properties like `manualErrorHandling`
   * and `handledByAxios`.
   *
   * Solution: Made axiosOptions accept arbitrary properties using index signature
   * to support module augmentation patterns.
   */
  describe('Custom Axios Properties Support (GitHub Issue)', () => {
    // Simulate the user's augmented types (this would normally be in types/axios.d.ts)
    interface AxiosErrorWithMetadata {
      isAxiosError: boolean
      message: string
    }

    it('should accept manualErrorHandling property without TypeScript errors', () => {
      // This exact code from the issue description should now work
      const currentUser = api.useQuery(OperationId.listPets, {
        onLoad: vi.fn(),
        axiosOptions: { manualErrorHandling: true },
      })

      expect(currentUser).toBeTruthy()
      expect(currentUser).toHaveProperty('data')
      expect(currentUser).toHaveProperty('isLoading')
    })

    it('should accept manualErrorHandling as function without TypeScript errors', () => {
      // Test the function variant mentioned in the augmented types
      const errorHandler = (error: AxiosErrorWithMetadata) => {
        console.log('Custom error handler called:', error.message)
        return true
      }

      const currentUser = api.useQuery(OperationId.listPets, {
        onLoad: vi.fn(),
        axiosOptions: {
          manualErrorHandling: errorHandler,
          handledByAxios: false,
        },
      })

      expect(currentUser).toBeTruthy()
      expect(currentUser).toHaveProperty('data')
      expect(currentUser).toHaveProperty('isLoading')
    })

    it('should accept both augmented properties from the issue', () => {
      // Test both properties mentioned in the user's augmented types
      const currentUser = api.useQuery(OperationId.listPets, {
        onLoad: vi.fn(),
        axiosOptions: {
          manualErrorHandling: true,
          handledByAxios: false,
        },
      })

      expect(currentUser).toBeTruthy()
      expect(currentUser).toHaveProperty('data')
      expect(currentUser).toHaveProperty('isLoading')
    })

    it('should work with mutations as well', () => {
      // Ensure the fix works for mutations too
      const createPet = api.useMutation(OperationId.createPet, {
        axiosOptions: {
          manualErrorHandling: true,
          handledByAxios: false,
        },
      })

      expect(createPet).toBeTruthy()
      expect(createPet).toHaveProperty('mutate')
      expect(createPet).toHaveProperty('mutateAsync')
    })

    it('should work in mutate calls', () => {
      // Ensure the fix works when passing axios options to mutate calls
      const createPet = api.useMutation(OperationId.createPet)

      expect(() => {
        createPet.mutate({
          data: { name: 'Test Pet' },
          axiosOptions: {
            manualErrorHandling: true,
            handledByAxios: false,
          },
        })
      }).not.toThrow()
    })

    it('should preserve standard axios properties alongside custom ones', () => {
      // Ensure standard axios properties still work with custom ones
      const currentUser = api.useQuery(OperationId.listPets, {
        onLoad: vi.fn(),
        axiosOptions: {
          // Standard axios properties
          timeout: 5000,
          headers: {
            Authorization: 'Bearer token',
            'Content-Type': 'application/json',
          },
          // Custom augmented properties
          manualErrorHandling: true,
          handledByAxios: false,
        },
      })

      expect(currentUser).toBeTruthy()
      expect(currentUser).toHaveProperty('data')
      expect(currentUser).toHaveProperty('isLoading')
    })

    it('should compile and run the exact code from the issue without TypeScript errors', () => {
      // This reproduces the EXACT scenario from the GitHub issue
      const options = {
        onLoad: vi.fn(),
      }

      // This is the EXACT code from the issue that was failing before
      const currentUser = api.useQuery(OperationId.listPets, {
        onLoad: options.onLoad,
        axiosOptions: { manualErrorHandling: true },
      })

      // Verify it works as expected
      expect(currentUser).toBeTruthy()
      expect(currentUser).toHaveProperty('data')
      expect(currentUser).toHaveProperty('isLoading')

      // Verify the onLoad function was passed correctly
      expect(currentUser).toHaveProperty('onLoad')
      expect(typeof currentUser.onLoad).toBe('function')
    })

    it('should work with the function variant of manualErrorHandling', () => {
      // Function variant as mentioned in the augmented types
      const errorHandler = (error: { isAxiosError: boolean; message: string }) => {
        console.log('Error handler called:', error.message)
        return true
      }

      const options = {
        onLoad: vi.fn(),
      }

      // Test the function variant
      const currentUser = api.useQuery(OperationId.listPets, {
        onLoad: options.onLoad,
        axiosOptions: {
          manualErrorHandling: errorHandler,
          handledByAxios: true,
        },
      })

      expect(currentUser).toBeTruthy()
      expect(currentUser).toHaveProperty('data')
      expect(currentUser).toHaveProperty('isLoading')
    })
  })

  /**
   * Issue: Type Inference for useEndpoint with Mutation Operations
   *
   * Problem: `useEndpoint` with mutation operations would return a union type,
   * preventing TypeScript from knowing that properties like `mutateAsync` are available.
   *
   * Solution: Improved type inference to properly detect operation types and return
   * specific types instead of union types.
   */
  describe('Type Inference for useEndpoint (GitHub Issue)', () => {
    it('should correctly infer mutation types for createPet operation', () => {
      // This reproduces the exact scenario from the GitHub issue
      const createEndpoint = api.useEndpoint(OperationId.createPet)

      // These should now work without TypeScript errors
      // Previously, this would fail with: Property 'mutateAsync' does not exist on type 'union type'
      expect(createEndpoint).toHaveProperty('mutate')
      expect(createEndpoint).toHaveProperty('mutateAsync')

      // Verify the methods are callable functions
      expect(typeof createEndpoint.mutate).toBe('function')
      expect(typeof createEndpoint.mutateAsync).toBe('function')

      // The key test: we can access mutateAsync directly without type errors
      const mutateAsyncFunction = createEndpoint.mutateAsync
      expect(mutateAsyncFunction).toBeDefined()
      expect(typeof mutateAsyncFunction).toBe('function')
    })

    it('should correctly infer mutation types for updatePet operation', () => {
      const updateEndpoint = api.useEndpoint(OperationId.updatePet, { petId: '123' })

      // Verify mutation properties are available
      expect(updateEndpoint).toHaveProperty('mutate')
      expect(updateEndpoint).toHaveProperty('mutateAsync')
      expect(updateEndpoint).toHaveProperty('isEnabled')

      // Verify these are functions
      expect(typeof updateEndpoint.mutate).toBe('function')
      expect(typeof updateEndpoint.mutateAsync).toBe('function')
    })

    it('should correctly infer query types for query operations', () => {
      // Test that query operations still work correctly with proper type inference
      const listEndpoint = api.useEndpoint(OperationId.listPets)

      // Should have query properties, not mutation properties
      expect(listEndpoint).toHaveProperty('data')
      expect(listEndpoint).toHaveProperty('isLoading')
      expect(listEndpoint).not.toHaveProperty('mutate')
      expect(listEndpoint).not.toHaveProperty('mutateAsync')
    })

    it('should correctly infer types for GET operations with path parameters', () => {
      const getEndpoint = api.useEndpoint(OperationId.getPet, { petId: '123' })

      // Should have query properties
      expect(getEndpoint).toHaveProperty('data')
      expect(getEndpoint).toHaveProperty('isLoading')
      expect(getEndpoint).toHaveProperty('queryKey')
    })

    it('should work with mutation operations not requiring variables', () => {
      // Test DELETE operations that might not require data variables
      const deleteEndpoint = api.useEndpoint(OperationId.deletePet, { petId: '123' })

      // Should have mutation properties
      expect(deleteEndpoint).toHaveProperty('mutate')
      expect(deleteEndpoint).toHaveProperty('mutateAsync')

      // Test with the standalone mutation as well
      const standaloneMutation = api.useMutation(OperationId.deletePet, { petId: '123' })

      // Both should have mutateAsync functions
      expect(typeof deleteEndpoint.mutateAsync).toBe('function')
      expect(typeof standaloneMutation.mutateAsync).toBe('function')

      // Call mutateAsync to ensure it works without vars (should not throw)
      expect(() => deleteEndpoint.mutateAsync()).not.toThrow()
      expect(() => standaloneMutation.mutateAsync()).not.toThrow()
    })

    it('should correctly infer types for mutation operations', () => {
      // This test specifically addresses the issue mentioned in the problem statement
      const createEndpoint = api.useEndpoint(OperationId.createPet)

      // These should now work without TypeScript errors
      expect(createEndpoint).toHaveProperty('mutate')
      expect(createEndpoint).toHaveProperty('mutateAsync')

      // Test that the methods exist and are callable (runtime verification)
      expect(typeof createEndpoint.mutate).toBe('function')
      expect(typeof createEndpoint.mutateAsync).toBe('function')

      // Test with typing - this should not cause TypeScript compilation errors
      const mutateFunction = createEndpoint.mutateAsync
      expect(mutateFunction).toBeDefined()
    })

    it('should work with different mutation types', () => {
      // Test various mutation operations
      const createEndpoint = api.useEndpoint(OperationId.createPet)
      const updateEndpoint = api.useEndpoint(OperationId.updatePet, { petId: '123' })
      const deleteEndpoint = api.useEndpoint(OperationId.deletePet, { petId: '123' })

      // All should have mutation properties
      expect(createEndpoint).toHaveProperty('mutate')
      expect(createEndpoint).toHaveProperty('mutateAsync')
      expect(updateEndpoint).toHaveProperty('mutate')
      expect(updateEndpoint).toHaveProperty('mutateAsync')
      expect(deleteEndpoint).toHaveProperty('mutate')
      expect(deleteEndpoint).toHaveProperty('mutateAsync')
    })
  })

  /**
   * Issue: Reactive Path Parameters Support
   *
   * Problem: Path parameters that start undefined and get updated later should
   * properly enable/disable queries and mutations.
   *
   * Solution: Improved reactive path parameter handling with proper enabled state management.
   */
  describe('Reactive Path Parameters (GitHub Issue)', () => {
    it('should handle reactive path params that start undefined and get updated', () => {
      // This test reproduces the exact scenario from the issue
      let userId: string | undefined = undefined

      // Create endpoint with reactive function for path params
      const myEndpoint = api.useEndpoint(OperationId.listUserPets, () => ({ userId }))

      // Initially, the path should not be resolved (contains {userId})
      expect(myEndpoint.isEnabled.value).toBe(false)

      // Update the userId - in a real Vue app with refs, this would be reactive
      userId = '123'

      // Note: In test environment, we can't fully simulate Vue's reactivity
      // but we can verify the endpoint structure is correct
      expect(myEndpoint).toBeTruthy()

      // Verify it's a query endpoint since listUserPets is GET
      expect(myEndpoint).toHaveProperty('data')
      expect(myEndpoint).not.toHaveProperty('mutateAsync')
    })

    it('should handle reactive path params with mutations', () => {
      let petId: string | undefined = undefined

      // Create mutation endpoint with reactive path params
      const updateEndpoint = api.useMutation(OperationId.updatePet, () => ({ petId }))

      // Initially should be disabled due to unresolved path params
      expect(updateEndpoint.isEnabled.value).toBe(false)

      // Update the petId
      petId = '123'

      // Verify it's a mutation endpoint
      expect(updateEndpoint).toHaveProperty('mutate')
      expect(updateEndpoint).toHaveProperty('mutateAsync')
    })

    it('should support reactive enabling based on parameter availability', () => {
      // Test automatic disabling when path parameters are undefined
      const queryWithoutParams = api.useQuery(OperationId.getPet, { petId: undefined })
      expect(queryWithoutParams.isEnabled.value).toBe(false)

      const queryWithParams = api.useQuery(OperationId.getPet, { petId: '123' })
      expect(queryWithParams.isEnabled.value).toBe(true)
    })

    it('should handle missing path parameters gracefully', () => {
      const query = api.useQuery(OperationId.getPet, { petId: undefined })
      expect(query.isEnabled.value).toBe(false)
      expect(query).toHaveProperty('data')
      expect(query).toHaveProperty('isLoading')
    })
  })

  /**
   * Issue: Multipart Form Data Support
   *
   * Problem: Need proper support for multipart/form-data requests with file uploads.
   *
   * Solution: Added support for FormData handling and proper content-type headers.
   */
  describe('Multipart Form Data Support (Feature Request)', () => {
    it('should handle FormData objects in mutation data', () => {
      const formData = new FormData()
      formData.append('name', 'Test Pet')
      formData.append('file', new Blob(['test'], { type: 'text/plain' }), 'test.txt')

      const mutation = api.useMutation(OperationId.createPet)

      expect(() => {
        mutation.mutate({
          data: formData,
          axiosOptions: {
            headers: {
              'Content-Type': 'multipart/form-data',
            },
          },
        })
      }).not.toThrow()
    })

    it('should automatically set content-type for FormData', () => {
      const formData = new FormData()
      formData.append('name', 'Test Pet')

      const mutation = api.useMutation(OperationId.createPet, {
        axiosOptions: {
          // Content-Type should be automatically set by axios for FormData
        },
      })

      expect(() => {
        mutation.mutate({ data: formData })
      }).not.toThrow()
    })

    it('should support file uploads with progress tracking', () => {
      const formData = new FormData()
      formData.append('file', new Blob(['test content'], { type: 'text/plain' }))

      const onUploadProgress = vi.fn()

      const mutation = api.useMutation(OperationId.createPet, {
        axiosOptions: {
          onUploadProgress,
        },
      })

      expect(() => {
        mutation.mutate({ data: formData })
      }).not.toThrow()
    })

    it('should handle mixed form data with additional axios options', () => {
      const formData = new FormData()
      formData.append('name', 'Test Pet')
      formData.append('description', 'A test pet for upload')

      const mutation = api.useMutation(OperationId.createPet)

      expect(() => {
        mutation.mutate({
          data: formData,
          axiosOptions: {
            timeout: 30000, // Longer timeout for file uploads
            onUploadProgress: (progressEvent) => {
              console.log('Upload progress:', progressEvent)
            },
          },
        })
      }).not.toThrow()
    })
  })

  /**
   * Issue: Error Handling Improvements
   *
   * Problem: Need better error handling patterns and custom error handlers.
   *
   * Solution: Added support for custom error handlers and improved error context.
   */
  describe('Error Handling Improvements (Enhancement)', () => {
    it('should support custom error handlers in queries', () => {
      const errorHandler = vi.fn((error) => {
        console.log('Custom error handler called:', error)
      })

      const query = api.useQuery(OperationId.listPets, {
        errorHandler,
      })

      expect(query).toHaveProperty('data')
      expect(query).toHaveProperty('isLoading')
    })

    it('should support async error handlers', () => {
      const errorHandler = vi.fn().mockResolvedValue(undefined)

      const query = api.useQuery(OperationId.listPets, {
        errorHandler,
      })

      expect(query).toHaveProperty('data')
    })

    it('should handle errors in mutations with custom handlers', () => {
      const mutation = api.useMutation(OperationId.createPet, {
        onError: vi.fn((error) => {
          console.log('Mutation error:', error)
        }),
      })

      expect(mutation).toHaveProperty('mutate')
      expect(mutation).toHaveProperty('mutateAsync')
    })

    it('should handle errors in mutate calls with catch blocks', () => {
      const mutation = api.useMutation(OperationId.createPet)

      expect(async () => {
        try {
          await mutation.mutateAsync({ data: { name: 'Test Pet' } })
        } catch (error) {
          console.log('Mutation error handled:', error)
        }
      }).not.toThrow()
    })
  })

  /**
   * Issue: Query Client Compatibility
   *
   * Problem: Need to ensure compatibility with different QueryClient configurations.
   *
   * Solution: Added support for custom QueryClient instances and proper defaults.
   */
  describe('Query Client Compatibility (Compatibility Issue)', () => {
    it('should work with custom QueryClient configuration', () => {
      const customQueryClient = {
        cancelQueries: vi.fn(() => Promise.resolve()),
        setQueryData: vi.fn(),
        invalidateQueries: vi.fn(() => Promise.resolve()),
      }
      const configWithClient: OpenApiConfig<OpenApiOperations> = {
        ...mockConfig,
        queryClient: customQueryClient,
      }

      const apiWithCustomClient = useOpenApi(configWithClient)
      expect(apiWithCustomClient).toBeTruthy()
      expect(apiWithCustomClient).toHaveProperty('useQuery')
      expect(apiWithCustomClient).toHaveProperty('useMutation')
      expect(apiWithCustomClient).toHaveProperty('useEndpoint')
    })

    it('should use default queryClient when not specified', () => {
      // This test verifies the api works without explicit queryClient
      expect(api).toBeTruthy()
      expect(api).toHaveProperty('useQuery')
      expect(api).toHaveProperty('useMutation')
      expect(api).toHaveProperty('useEndpoint')
    })
  })

  /**
   * Feature: Multipart Form Data Support
   *
   * Problem: Need proper support for multipart/form-data requests with file uploads.
   *
   * Solution: Added support for FormData handling and proper content-type headers.
   */
  describe('Multipart Form Data Support (Feature Request)', () => {
    it('should handle FormData objects in mutation data', () => {
      const formData = new FormData()
      formData.append('name', 'Test Pet')
      formData.append('file', new Blob(['test'], { type: 'text/plain' }), 'test.txt')

      const mutation = api.useMutation(OperationId.createPet)

      expect(() => {
        mutation.mutate({
          data: formData,
          axiosOptions: {
            headers: {
              'Content-Type': 'multipart/form-data',
            },
          },
        })
      }).not.toThrow()
    })

    it('should automatically set content-type for FormData', () => {
      const formData = new FormData()
      formData.append('name', 'Test Pet')

      const mutation = api.useMutation(OperationId.createPet, {
        axiosOptions: {
          // Content-Type should be automatically set by axios for FormData
        },
      })

      expect(() => {
        mutation.mutate({ data: formData })
      }).not.toThrow()
    })

    it('should support file uploads with progress tracking', () => {
      const formData = new FormData()
      formData.append('file', new Blob(['test content'], { type: 'text/plain' }))

      const onUploadProgress = vi.fn()

      const mutation = api.useMutation(OperationId.createPet, {
        axiosOptions: {
          onUploadProgress,
        },
      })

      expect(() => {
        mutation.mutate({ data: formData })
      }).not.toThrow()
    })

    it('should handle mixed form data with additional axios options', () => {
      const formData = new FormData()
      formData.append('name', 'Test Pet')
      formData.append('description', 'A test pet for upload')

      const mutation = api.useMutation(OperationId.createPet)

      expect(() => {
        mutation.mutate({
          data: formData,
          axiosOptions: {
            timeout: 30000, // Longer timeout for file uploads
            onUploadProgress: (progressEvent) => {
              console.log('Upload progress:', progressEvent)
            },
          },
        })
      }).not.toThrow()
    })

    it('should support multipart/form-data with specific upload endpoints', () => {
      // Test with upload-specific endpoint if available
      const uploadMutation = api.useMutation(OperationId.uploadPetPic, { petId: '123' })

      const mockFile = new File(['test content'], 'test.jpg', { type: 'image/jpeg' })
      const formData = new FormData()
      formData.append('file', mockFile)

      expect(() => {
        uploadMutation.mutateAsync({
          data: formData,
        })
      }).not.toThrow()

      expect(uploadMutation).toHaveProperty('mutate')
      expect(uploadMutation).toHaveProperty('mutateAsync')
    })

    it('should support custom headers with multipart uploads', () => {
      const uploadMutation = api.useMutation(
        OperationId.uploadPetPic,
        { petId: '123' },
        {
          axiosOptions: {
            headers: {
              'Content-Type': 'multipart/form-data',
              'X-Custom-Header': 'custom-value',
            },
          },
        },
      )

      const mockFile = new File(['test content'], 'test.jpg', { type: 'image/jpeg' })
      const formData = new FormData()
      formData.append('file', mockFile)

      expect(() => {
        uploadMutation.mutateAsync({
          data: formData,
        })
      }).not.toThrow()
    })

    it('should support type safety for multipart/form-data schemas', () => {
      const uploadMutation = api.useMutation(OperationId.uploadPetPic, { petId: '123' })

      // Should accept FormData
      expect(() => {
        uploadMutation.mutateAsync({
          data: new FormData(),
        })
      }).not.toThrow()

      // Should also accept object matching the schema
      expect(() => {
        uploadMutation.mutateAsync({
          data: {
            file: 'binary-data-string', // As per OpenAPI spec, file is string with format: binary
          },
        })
      }).not.toThrow()
    })

    it('should integrate with cache invalidation after upload', () => {
      const listPetsQuery = api.useQuery(OperationId.listPets)
      const uploadMutation = api.useMutation(
        OperationId.uploadPetPic,
        { petId: '123' },
        {
          invalidateOperations: [OperationId.listPets],
        },
      )

      const formData = new FormData()
      formData.append('file', new File(['test'], 'test.jpg'))

      expect(uploadMutation).toBeTruthy()
      expect(listPetsQuery).toBeTruthy()
    })
  })
})
