import { describe, it, expect } from 'vitest'

// Import the OpenAPI specification for testing
import toyOpenApiSpec from '../fixtures/toy-openapi.json'

describe('CLI codegen functionality', () => {
  describe('parseOperationsFromSpec', () => {
    // We'll test this function by creating a pure implementation
    // since we can't easily import the actual CLI module due to Node.js dependencies

    const parseOperationsFromSpec = (openapiContent: string) => {
      const openApiSpec = JSON.parse(openapiContent)

      if (!openApiSpec.paths) {
        throw new Error('Invalid OpenAPI spec: missing paths')
      }

      const operationIds: string[] = []
      const operationInfoMap: Record<string, { path: string; method: string }> = {}

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Object.entries(openApiSpec.paths).forEach(([pathUrl, pathItem]: [string, any]) => {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Object.entries(pathItem).forEach(([method, operation]: [string, any]) => {
          const httpMethods = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head', 'trace']
          if (!httpMethods.includes(method.toLowerCase())) {
            return
          }

          if (operation.operationId) {
            operationIds.push(operation.operationId)
            operationInfoMap[operation.operationId] = {
              path: pathUrl,
              method: method.toUpperCase(),
            }
          }
        })
      })

      operationIds.sort()

      return { operationIds, operationInfoMap }
    }

    it('should extract operation IDs from OpenAPI spec', () => {
      const openapiContent = JSON.stringify(toyOpenApiSpec)
      const result = parseOperationsFromSpec(openapiContent)

      expect(result.operationIds).toEqual([
        'createPet',
        'deletePet',
        'getPet',
        'listPets',
        'listUserPets',
        'updatePet',
        'uploadPetPic',
      ])
    })

    it('should create operation info map with correct structure', () => {
      const openapiContent = JSON.stringify(toyOpenApiSpec)
      const result = parseOperationsFromSpec(openapiContent)

      expect(result.operationInfoMap).toEqual({
        listPets: { path: '/pets', method: 'GET' },
        createPet: { path: '/pets', method: 'POST' },
        getPet: { path: '/pets/{petId}', method: 'GET' },
        updatePet: { path: '/pets/{petId}', method: 'PUT' },
        deletePet: { path: '/pets/{petId}', method: 'DELETE' },
        listUserPets: { path: '/users/{userId}/pets', method: 'GET' },
        uploadPetPic: { path: '/pets/{petId}/upload', method: 'POST' },
      })
    })

    it('should handle OpenAPI spec without paths', () => {
      const invalidSpec = JSON.stringify({ openapi: '3.0.0', info: { title: 'Test' } })

      expect(() => parseOperationsFromSpec(invalidSpec)).toThrow('Invalid OpenAPI spec: missing paths')
    })

    it('should ignore non-HTTP methods', () => {
      const specWithParameters = {
        openapi: '3.0.0',
        info: { title: 'Test' },
        paths: {
          '/test': {
            parameters: [{ name: 'test', in: 'query' }],
            get: { operationId: 'getTest' },
          },
        },
      }

      const result = parseOperationsFromSpec(JSON.stringify(specWithParameters))
      expect(result.operationIds).toEqual(['getTest'])
    })

    it('should skip operations without operationId', () => {
      const specWithoutOperationId = {
        openapi: '3.0.0',
        info: { title: 'Test' },
        paths: {
          '/test': {
            get: { summary: 'Get test' }, // No operationId
          },
        },
      }

      const result = parseOperationsFromSpec(JSON.stringify(specWithoutOperationId))
      expect(result.operationIds).toEqual([])
      expect(result.operationInfoMap).toEqual({})
    })
  })

  describe('generateApiOperationsContent', () => {
    const generateApiOperationsContent = (
      operationIds: string[],
      operationInfoMap: Record<string, { path: string; method: string }>,
    ): string => {
      // Generate operationsBase dictionary
      const operationsBaseContent = operationIds
        .map((id) => {
          const info = operationInfoMap[id]
          return `  ${id}: {\n    path: '${info.path}',\n    method: HttpMethod.${info.method},\n  },`
        })
        .join('\n')

      // Generate OperationId enum content
      const operationIdContent = operationIds.map((id) => `  ${id}: '${id}' as const,`).join('\n')

      return `// Auto-generated from OpenAPI specification
// Do not edit this file manually

import type { operations } from './openapi-types'

export enum HttpMethod {
  GET = 'GET',
  POST = 'POST',
  PUT = 'PUT',
  PATCH = 'PATCH',
  DELETE = 'DELETE',
  HEAD = 'HEAD',
  OPTIONS = 'OPTIONS',
  TRACE = 'TRACE',
}

// Create the typed structure that combines operations with operation metadata
// This ensures the debug method returns correct values and all operations are properly typed
const operationsBase = {
${operationsBaseContent}
} as const

// Merge with operations type to maintain OpenAPI type information
export const openApiOperations = operationsBase as typeof operationsBase & operations

export type OpenApiOperations = typeof openApiOperations

// Dynamically generate OperationId enum from the operations keys
export const OperationId = {
${operationIdContent}
} satisfies Record<keyof typeof operationsBase, keyof typeof operationsBase>

// Export the type for TypeScript inference
export type OperationId = keyof OpenApiOperations
`
    }

    it('should generate correct TypeScript content', () => {
      const operationIds = ['listPets', 'createPet', 'getPet']
      const operationInfoMap = {
        listPets: { path: '/pets', method: 'GET' },
        createPet: { path: '/pets', method: 'POST' },
        getPet: { path: '/pets/{petId}', method: 'GET' },
      }

      const content = generateApiOperationsContent(operationIds, operationInfoMap)

      expect(content).toContain("import type { operations } from './openapi-types'")
      expect(content).toContain('export enum HttpMethod {')
      expect(content).toContain('const operationsBase = {')
      expect(content).toContain('export const openApiOperations = operationsBase as typeof operationsBase & operations')
      expect(content).toContain('export type OpenApiOperations = typeof openApiOperations')
      expect(content).toContain('export const OperationId = {')
      expect(content).toContain("listPets: 'listPets' as const,")
      expect(content).toContain("createPet: 'createPet' as const,")
      expect(content).toContain("getPet: 'getPet' as const,")
      expect(content).toContain("listPets: {\n    path: '/pets',\n    method: HttpMethod.GET,\n  },")
      expect(content).toContain("createPet: {\n    path: '/pets',\n    method: HttpMethod.POST,\n  },")
      expect(content).toContain("getPet: {\n    path: '/pets/{petId}',\n    method: HttpMethod.GET,\n  },")
      expect(content).toContain('} satisfies Record<keyof typeof operationsBase, keyof typeof operationsBase>')
      expect(content).toContain('export type OperationId = keyof OpenApiOperations')
    })

    it('should handle empty operation lists', () => {
      const content = generateApiOperationsContent([], {})

      expect(content).toContain('const operationsBase = {\n\n} as const')
      expect(content).toContain(
        'export const OperationId = {\n\n} satisfies Record<keyof typeof operationsBase, keyof typeof operationsBase>',
      )
    })

    it('should generate valid TypeScript for toy OpenAPI spec', () => {
      const openapiContent = JSON.stringify(toyOpenApiSpec)
      const parseOperationsFromSpec = (content: string) => {
        const openApiSpec = JSON.parse(content)
        const operationIds: string[] = []
        const operationInfoMap: Record<string, { path: string; method: string }> = {}

        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Object.entries(openApiSpec.paths).forEach(([pathUrl, pathItem]: [string, any]) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          Object.entries(pathItem).forEach(([method, operation]: [string, any]) => {
            const httpMethods = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head', 'trace']
            if (!httpMethods.includes(method.toLowerCase())) return

            if (operation.operationId) {
              operationIds.push(operation.operationId)
              operationInfoMap[operation.operationId] = {
                path: pathUrl,
                method: method.toUpperCase(),
              }
            }
          })
        })

        operationIds.sort()
        return { operationIds, operationInfoMap }
      }

      const { operationIds, operationInfoMap } = parseOperationsFromSpec(openapiContent)
      const content = generateApiOperationsContent(operationIds, operationInfoMap)

      // Verify all operations from toy spec are present
      expect(content).toContain("createPet: 'createPet'")
      expect(content).toContain("deletePet: 'deletePet'")
      expect(content).toContain("getPet: 'getPet'")
      expect(content).toContain("listPets: 'listPets'")
      expect(content).toContain("listUserPets: 'listUserPets'")
      expect(content).toContain("updatePet: 'updatePet'")
    })
  })

  describe('URL validation patterns', () => {
    it('should identify HTTP URLs correctly', () => {
      const httpUrl = 'http://api.example.com/openapi.json'
      const httpsUrl = 'https://api.example.com/openapi.json'
      const localFile = './tests/fixtures/toy-openapi.json'

      expect(httpUrl.startsWith('http://')).toBe(true)
      expect(httpsUrl.startsWith('https://')).toBe(true)
      expect(localFile.startsWith('http://') || localFile.startsWith('https://')).toBe(false)
    })

    it('should validate command line arguments format', () => {
      const validateArgs = (args: string[]) => {
        if (args.length !== 2) {
          throw new Error('Exactly 2 arguments are required')
        }
        return { openapiInput: args[0], outputDir: args[1] }
      }

      expect(() => validateArgs([])).toThrow('Exactly 2 arguments are required')
      expect(() => validateArgs(['input'])).toThrow('Exactly 2 arguments are required')
      expect(() => validateArgs(['input', 'output', 'extra'])).toThrow('Exactly 2 arguments are required')

      const valid = validateArgs(['input.json', 'output/'])
      expect(valid).toEqual({ openapiInput: 'input.json', outputDir: 'output/' })
    })
  })
})
